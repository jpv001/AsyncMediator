using System.Collections.Immutable;
using System.Text;
using AsyncMediator.SourceGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AsyncMediator.SourceGenerator.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class HandlerDiscoveryGenerator : IIncrementalGenerator
{
    private const string CommandHandlerInterface = "ICommandHandler";
    private const string EventHandlerInterface = "IEventHandler";
    private const string QueryInterface = "IQuery";
    private const string LookupQueryInterface = "ILookupQuery";
    private const string ExcludeAttributeName = "ExcludeFromMediatorAttribute";
    private const string MediatorHandlerAttributeName = "MediatorHandlerAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(GenerateAttributes);

        var handlerCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsPotentialHandler(node),
                transform: static (ctx, _) => GetHandlerInfos(ctx))
            .SelectMany(static (handlers, _) => handlers);

        var allHandlers = handlerCandidates.Collect();

        context.RegisterSourceOutput(allHandlers, GenerateRegistrationCode);
    }

    private static bool IsPotentialHandler(SyntaxNode node) =>
        node is ClassDeclarationSyntax { BaseList: not null } classDecl &&
        !classDecl.Modifiers.Any(SyntaxKind.AbstractKeyword) &&
        !classDecl.Modifiers.Any(SyntaxKind.StaticKeyword);

    private static ImmutableArray<HandlerInfo> GetHandlerInfos(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(classDecl) is not INamedTypeSymbol symbol || symbol.IsAbstract)
            return [];

        if (HasAttribute(symbol, ExcludeAttributeName))
            return [];

        var lifetime = GetLifetimeFromAttribute(symbol);
        var handlers = ImmutableArray.CreateBuilder<HandlerInfo>();

        foreach (var iface in symbol.AllInterfaces)
        {
            if (!IsAsyncMediatorInterface(iface))
                continue;

            var category = GetCategory(iface.Name);
            if (category is null) continue;

            handlers.Add(new HandlerInfo(
                symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                category.Value,
                lifetime));
        }

        return handlers.ToImmutable();
    }

    private static bool IsAsyncMediatorInterface(INamedTypeSymbol interfaceSymbol)
    {
        var ns = interfaceSymbol.ContainingNamespace?.ToDisplayString();
        return ns is "AsyncMediator" or "AsyncMediator.Interfaces";
    }

    private static HandlerCategory? GetCategory(string interfaceName) => interfaceName switch
    {
        CommandHandlerInterface => HandlerCategory.Command,
        EventHandlerInterface => HandlerCategory.Event,
        QueryInterface => HandlerCategory.Query,
        LookupQueryInterface => HandlerCategory.LookupQuery,
        _ => null
    };

    private static bool HasAttribute(INamedTypeSymbol symbol, string attributeName) =>
        symbol.GetAttributes().Any(a =>
        {
            if (a.AttributeClass is null) return false;
            var ns = a.AttributeClass.ContainingNamespace?.ToDisplayString();
            if (ns != "AsyncMediator") return false;
            return a.AttributeClass.Name == attributeName ||
                   a.AttributeClass.Name == attributeName.Replace("Attribute", "");
        });

    private static string? GetLifetimeFromAttribute(INamedTypeSymbol symbol)
    {
        var attr = symbol.GetAttributes().FirstOrDefault(a =>
        {
            if (a.AttributeClass is null) return false;
            var ns = a.AttributeClass.ContainingNamespace?.ToDisplayString();
            if (ns != "AsyncMediator") return false;
            return a.AttributeClass.Name is MediatorHandlerAttributeName or "MediatorHandler";
        });

        if (attr is null) return null;

        var lifetimeArg = attr.NamedArguments.FirstOrDefault(a => a.Key == "Lifetime");
        return lifetimeArg.Value.Value is int lifetime ? lifetime switch
        {
            0 => "Singleton",
            1 => "Scoped",
            2 => "Transient",
            _ => null
        } : null;
    }

    private static void GenerateAttributes(IncrementalGeneratorPostInitializationContext context) =>
        context.AddSource("AsyncMediatorAttributes.g.cs", """
            // <auto-generated/>
            #nullable enable

            namespace AsyncMediator;

            /// <summary>
            /// Excludes a handler from automatic mediator registration.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
            internal sealed class ExcludeFromMediatorAttribute : global::System.Attribute { }

            /// <summary>
            /// Specifies the service lifetime for a mediator handler.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
            internal sealed class MediatorHandlerAttribute : global::System.Attribute
            {
                /// <summary>
                /// Gets or sets the service lifetime for this handler.
                /// </summary>
                /// <value>
                /// <list type="bullet">
                /// <item><description>0 = Singleton (one instance for application lifetime)</description></item>
                /// <item><description>1 = Scoped (one instance per scope/request) [default]</description></item>
                /// <item><description>2 = Transient (new instance every time)</description></item>
                /// </list>
                /// </value>
                public int Lifetime { get; set; } = 1;
            }

            /// <summary>
            /// Marks a message or handler as draft/work-in-progress.
            /// </summary>
            [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
            internal sealed class MediatorDraftAttribute : global::System.Attribute
            {
                /// <summary>
                /// Gets or sets the reason this is marked as draft.
                /// </summary>
                public string? Reason { get; set; }
            }
            """);

    private static void GenerateRegistrationCode(SourceProductionContext context, ImmutableArray<HandlerInfo> handlers)
    {
        var registrations = new StringBuilder();
        var commands = handlers.Where(h => h.Category == HandlerCategory.Command).ToList();
        var events = handlers.Where(h => h.Category == HandlerCategory.Event).ToList();
        var queries = handlers.Where(h => h.Category is HandlerCategory.Query or HandlerCategory.LookupQuery).ToList();

        foreach (var handler in handlers)
        {
            var lifetimeValue = handler.Lifetime is not null
                ? $"global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.{handler.Lifetime}"
                : "defaultLifetime";

            registrations.AppendLine($"""
                        services.Add(new global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor(
                            typeof({handler.ServiceInterfaceFullName}),
                            typeof({handler.FullTypeName}),
                            {lifetimeValue}));
            """);
        }

        context.AddSource("AsyncMediatorRegistration.g.cs", $$"""
            // <auto-generated/>
            #nullable enable

            namespace Microsoft.Extensions.DependencyInjection;

            internal static class AsyncMediatorGeneratedRegistrations
            {
                internal static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddGeneratedHandlers(
                    this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services,
                    global::Microsoft.Extensions.DependencyInjection.ServiceLifetime defaultLifetime = global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped)
                {
            {{registrations}}
                    return services;
                }

                internal const int HandlerCount = {{handlers.Length}};
                internal const int CommandHandlerCount = {{commands.Count}};
                internal const int EventHandlerCount = {{events.Count}};
                internal const int QueryHandlerCount = {{queries.Count}};
            }
            """);

        GenerateExtensions(context);
        GenerateBuilder(context);
    }

    private static void GenerateExtensions(SourceProductionContext context) =>
        context.AddSource("AsyncMediatorExtensions.g.cs", """
            // <auto-generated/>
            #nullable enable

            namespace Microsoft.Extensions.DependencyInjection;

            public static class AsyncMediatorServiceCollectionExtensions
            {
                public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddAsyncMediator(
                    this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services,
                    global::System.Action<AsyncMediatorBuilder>? configure = null)
                {
                    var builder = new AsyncMediatorBuilder(services);
                    configure?.Invoke(builder);

                    AsyncMediatorGeneratedRegistrations.AddGeneratedHandlers(services, builder.DefaultLifetime);

                    services.Add(new global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor(
                        typeof(global::AsyncMediator.IMediator),
                        sp => new global::AsyncMediator.Mediator(
                            multiInstanceFactory: type => (global::System.Collections.Generic.IEnumerable<object>)sp.GetServices(type),
                            singleInstanceFactory: type => sp.GetRequiredService(type),
                            behaviors: null,
                            behaviorFactory: builder.HasBehaviors
                                ? type => (global::System.Collections.Generic.IEnumerable<object>)sp.GetServices(type)
                                : null),
                        builder.MediatorLifetime));

                    return services;
                }
            }
            """);

    private static void GenerateBuilder(SourceProductionContext context) =>
        context.AddSource("AsyncMediatorBuilder.g.cs", """
            // <auto-generated/>
            #nullable enable

            namespace Microsoft.Extensions.DependencyInjection;

            public sealed class AsyncMediatorBuilder(global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)
            {
                public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime DefaultLifetime { get; set; } =
                    global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped;

                public global::Microsoft.Extensions.DependencyInjection.ServiceLifetime MediatorLifetime { get; set; } =
                    global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped;

                /// <summary>
                /// Gets a value indicating whether any behaviors have been registered.
                /// Used to conditionally provide a behavior factory at runtime.
                /// </summary>
                internal bool HasBehaviors { get; private set; }

                /// <summary>
                /// Adds a closed generic pipeline behavior. The behavior is registered against
                /// each specific IPipelineBehavior&lt;TRequest, TResponse&gt; interface it implements.
                /// For open generic behaviors, use <see cref="AddOpenGenericBehavior"/> instead.
                /// </summary>
                public AsyncMediatorBuilder AddBehavior<TBehavior>(
                    global::Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime =
                        global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient)
                    where TBehavior : class
                {
                    var behaviorType = typeof(TBehavior);
                    var pipelineInterface = typeof(global::AsyncMediator.IPipelineBehavior<,>);
                    var registered = false;

                    // Register against each specific closed IPipelineBehavior<TRequest, TResponse> interface
                    foreach (var iface in behaviorType.GetInterfaces())
                    {
                        if (!iface.IsGenericType) continue;
                        if (iface.GetGenericTypeDefinition() != pipelineInterface) continue;

                        services.Add(new global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor(
                            iface, behaviorType, lifetime));
                        registered = true;
                    }

                    if (!registered)
                        throw new global::System.ArgumentException(
                            $"Type {behaviorType.Name} does not implement IPipelineBehavior<TRequest, TResponse>. " +
                            "Use AddOpenGenericBehavior for open generic behaviors.", nameof(TBehavior));

                    HasBehaviors = true;
                    return this;
                }

                public AsyncMediatorBuilder AddOpenGenericBehavior(
                    global::System.Type openGenericBehaviorType,
                    global::Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime =
                        global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Transient)
                {
                    services.Add(new global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor(
                        typeof(global::AsyncMediator.IPipelineBehavior<,>), openGenericBehaviorType, lifetime));
                    HasBehaviors = true;
                    return this;
                }

                public AsyncMediatorBuilder WithDefaultLifetime(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime)
                {
                    DefaultLifetime = lifetime;
                    return this;
                }

                public AsyncMediatorBuilder WithMediatorLifetime(global::Microsoft.Extensions.DependencyInjection.ServiceLifetime lifetime)
                {
                    MediatorLifetime = lifetime;
                    return this;
                }
            }
            """);
}
